---
layout: post
title: 'Extracting a Verified Interpreter from Isabelle/HOL'
tags: formal_methods pl_theory
author: Alex Weisberger
---

Sometimes building a language is the best solution to a problem. This takes on many forms, from [designing DSLs to implement an OS shell](https://www.oilshell.org/blog/2022/03/middle-out.html) to [more ambitious languages for verifying filesystems](https://trustworthy.systems/projects/TS/cogent.pml). Since we're in [the Golden Age of PL Research](https://semantic-domain.blogspot.com/2022/09/the-golden-age-of-pl-research.html), there are plenty of reasons to give language design a try!

Languages are foundational, though, and soundness issues in them affect all of their programs. This makes them a great candididate for formalization and verification, since the cost of errors is very high, but as usual that means we have to address [the verification gap]({% post_url 2022-07-12-verification-gap %}). In this post we'll cross the gap by building and (partially) verifying an operational semantics of a small language in [Isabelle/HOL](https://isabelle.in.tum.de/), and we'll extract this semantics into an executable interpreter in OCaml.



# The Language: Boolean Expressions

Let's keep the language simple to focus on the end-to-end process of extraction. Our language will allow expressing and evaluating boolean expressions and conditionals, like "if true then true else false" (this is just the untyped boolean expression language from Chapter 3 of [Types and Programming Languages](https://www.cis.upenn.edu/~bcpierce/tapl/)).

First, we define the (abstract) syntax, in Isabelle:

<pre class="source"><span class="keyword1"><span class="command"><span class="entity_def" id="BoolExp.arity_full_exhaustive_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.full_exhaustive_boolexp.simps|fact"><span class="entity_def" id="BoolExp.full_exhaustive_boolexp_inst.full_exhaustive_boolexp|fact"><span class="entity_def" id="BoolExp.arity_narrowing_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.narrowing_boolexp.simps|fact"><span class="entity_def" id="BoolExp.narrowing_boolexp_inst.narrowing_boolexp|fact"><span class="entity_def" id="BoolExp.arity_random_boolexp|fact"><span class="entity_def" id="BoolExp.random_boolexp_def|fact"><span class="entity_def" id="BoolExp.random_boolexp_inst.random_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.random_aux.simps|fact"><span class="entity_def" id="BoolExp.random_aux_boolexp_def|fact"><span class="entity_def" id="BoolExp.boolexp.size_gen|fact"><span class="entity_def" id="BoolExp.boolexp.size|fact"><span class="entity_def" id="BoolExp.arity_size_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.size_boolexp_overloaded_def|fact"><span class="entity_def" id="BoolExp.size_boolexp_inst.size_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.size_boolexp_def|fact"><span class="entity_def" id="BoolExp.boolexp.simps|fact"><span class="entity_def" id="BoolExp.boolexp.rec_transfer|fact"><span class="entity_def" id="BoolExp.boolexp.rec|fact"><span class="entity_def" id="BoolExp.boolexp.induct|fact"><span class="entity_def" id="BoolExp.boolexp.case_transfer|fact"><span class="entity_def" id="BoolExp.boolexp.splits|fact"><span class="entity_def" id="BoolExp.boolexp.split_asm|fact"><span class="entity_def" id="BoolExp.boolexp.split|fact"><span class="entity_def" id="BoolExp.boolexp.nchotomy|fact"><span class="entity_def" id="BoolExp.boolexp.inject|fact"><span class="entity_def" id="BoolExp.boolexp.exhaust|fact"><span class="entity_def" id="BoolExp.boolexp.distinct|fact"><span class="entity_def" id="BoolExp.boolexp.case_distrib|fact"><span class="entity_def" id="BoolExp.boolexp.case_cong_weak|fact"><span class="entity_def" id="BoolExp.boolexp.case_cong|fact"><span class="entity_def" id="BoolExp.boolexp.case|fact"><span class="entity_def" id="BoolExp.boolexp.eq.simps|fact"><span class="entity_def" id="BoolExp.boolexp.eq.refl|fact"><span class="entity_def" id="BoolExp.arity_equal_boolexp|fact"><span class="entity_def" id="BoolExp.equal_boolexp_def|fact"><span class="entity_def" id="BoolExp.equal_boolexp_inst.equal_boolexp|fact"><span class="entity_def" id="BoolExp.arity_partial_term_of_boolexp|fact"><span class="entity_def" id="BoolExp.partial_term_of_boolexp_triv|fact"><span class="entity_def" id="BoolExp.partial_term_of_boolexp_inst.partial_term_of_boolexp|fact"><span class="entity_def" id="BoolExp.arity_term_of_boolexp|fact"><span class="entity_def" id="BoolExp.term_of_boolexp_triv|fact"><span class="entity_def" id="BoolExp.term_of_boolexp_inst.term_of_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.case_boolexp_def|fact"><span class="entity_def" id="BoolExp.boolexp.ctor_rec_boolexp_def|fact"><span class="entity_def" id="BoolExp.boolexp.dtor_boolexp_def|fact"><span class="entity_def" id="BoolExp.boolexp.ctor_fold_boolexp_def|fact"><span class="entity_def" id="BoolExp.boolexp.ctor_boolexp_def|fact"><span class="entity_def" id="BoolExp.arity_typerep_boolexp|fact"><span class="entity_def" id="BoolExp.typerep_boolexp_def|fact"><span class="entity_def" id="BoolExp.typerep_boolexp_inst.typerep_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.Abs_boolexp_induct|fact"><span class="entity_def" id="BoolExp.boolexp.Rep_boolexp_induct|fact"><span class="entity_def" id="BoolExp.boolexp.Abs_boolexp_cases|fact"><span class="entity_def" id="BoolExp.boolexp.Rep_boolexp_cases|fact"><span class="entity_def" id="BoolExp.boolexp.Abs_boolexp_inject|fact"><span class="entity_def" id="BoolExp.boolexp.Rep_boolexp_inject|fact"><span class="entity_def" id="BoolExp.boolexp.Abs_boolexp_inverse|fact"><span class="entity_def" id="BoolExp.boolexp.Rep_boolexp_inverse|fact"><span class="entity_def" id="BoolExp.boolexp.Rep_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.type_definition_boolexp|fact"><span class="entity_def" id="BoolExp.arity_type_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.str_init_boolexp_def|fact"><span class="entity_def" id="BoolExp.boolexp.arity_typerep_boolexp_IITN_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.typerep_boolexp_IITN_boolexp_def|fact"><span class="entity_def" id="BoolExp.boolexp.typerep_boolexp_IITN_boolexp_inst.typerep_boolexp_IITN_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Abs_boolexp_IITN_boolexp_induct|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Rep_boolexp_IITN_boolexp_induct|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Abs_boolexp_IITN_boolexp_cases|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Rep_boolexp_IITN_boolexp_cases|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Abs_boolexp_IITN_boolexp_inject|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Rep_boolexp_IITN_boolexp_inject|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Abs_boolexp_IITN_boolexp_inverse|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Rep_boolexp_IITN_boolexp_inverse|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Rep_boolexp_IITN_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.type_definition_boolexp_IITN_boolexp|fact"><span class="entity_def" id="BoolExp.arity_type_boolexp_IITN_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.min_alg_boolexp_def|fact"><span class="entity_def" id="BoolExp.boolexp.mor_boolexp_def|fact"><span class="entity_def" id="BoolExp.boolexp.alg_boolexp_def|fact"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.set_pre_boolexp_def|fact"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.rel_pre_boolexp_def|fact"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.map_pre_boolexp_def|fact"><span class="entity_def" id="BoolExp.boolexp.arity_typerep_boolexp_pre_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.typerep_boolexp_pre_boolexp_def|fact"><span class="entity_def" id="BoolExp.boolexp.typerep_boolexp_pre_boolexp_inst.typerep_boolexp_pre_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Abs_boolexp_pre_boolexp_induct|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Rep_boolexp_pre_boolexp_induct|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Abs_boolexp_pre_boolexp_cases|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Rep_boolexp_pre_boolexp_cases|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Abs_boolexp_pre_boolexp_inject|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Rep_boolexp_pre_boolexp_inject|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Abs_boolexp_pre_boolexp_inverse|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Rep_boolexp_pre_boolexp_inverse|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Rep_boolexp_pre_boolexp|fact"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.type_definition_boolexp_pre_boolexp|fact"><span class="entity_def" id="BoolExp.arity_type_boolexp_pre_boolexp|fact"><span class="entity_def" id="BoolExp.arity_full_exhaustive_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.full_exhaustive_boolexp.simps|thm"><span class="entity_def" id="BoolExp.full_exhaustive_boolexp_inst.full_exhaustive_boolexp|thm"><span class="entity_def" id="BoolExp.arity_narrowing_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.narrowing_boolexp.simps|thm"><span class="entity_def" id="BoolExp.narrowing_boolexp_inst.narrowing_boolexp|thm"><span class="entity_def" id="BoolExp.arity_random_boolexp|thm"><span class="entity_def" id="BoolExp.random_boolexp_def|thm"><span class="entity_def" id="BoolExp.random_boolexp_inst.random_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.random_aux.simps|thm"><span class="entity_def" id="BoolExp.random_aux_boolexp_def|thm"><span class="entity_def" id="BoolExp.boolexp.size_gen(3)|thm"><span class="entity_def" id="BoolExp.boolexp.size_gen(2)|thm"><span class="entity_def" id="BoolExp.boolexp.size_gen(1)|thm"><span class="entity_def" id="BoolExp.boolexp.size(6)|thm"><span class="entity_def" id="BoolExp.boolexp.size(5)|thm"><span class="entity_def" id="BoolExp.boolexp.size(4)|thm"><span class="entity_def" id="BoolExp.boolexp.size(3)|thm"><span class="entity_def" id="BoolExp.boolexp.size(2)|thm"><span class="entity_def" id="BoolExp.boolexp.size(1)|thm"><span class="entity_def" id="BoolExp.arity_size_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.size_boolexp_overloaded_def|thm"><span class="entity_def" id="BoolExp.size_boolexp_inst.size_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.size_boolexp_def|thm"><span class="entity_def" id="BoolExp.boolexp.simps(13)|thm"><span class="entity_def" id="BoolExp.boolexp.simps(12)|thm"><span class="entity_def" id="BoolExp.boolexp.simps(11)|thm"><span class="entity_def" id="BoolExp.boolexp.simps(10)|thm"><span class="entity_def" id="BoolExp.boolexp.simps(9)|thm"><span class="entity_def" id="BoolExp.boolexp.simps(8)|thm"><span class="entity_def" id="BoolExp.boolexp.simps(7)|thm"><span class="entity_def" id="BoolExp.boolexp.simps(6)|thm"><span class="entity_def" id="BoolExp.boolexp.simps(5)|thm"><span class="entity_def" id="BoolExp.boolexp.simps(4)|thm"><span class="entity_def" id="BoolExp.boolexp.simps(3)|thm"><span class="entity_def" id="BoolExp.boolexp.simps(2)|thm"><span class="entity_def" id="BoolExp.boolexp.simps(1)|thm"><span class="entity_def" id="BoolExp.boolexp.rec_transfer|thm"><span class="entity_def" id="BoolExp.boolexp.rec(3)|thm"><span class="entity_def" id="BoolExp.boolexp.rec(2)|thm"><span class="entity_def" id="BoolExp.boolexp.rec(1)|thm"><span class="entity_def" id="BoolExp.boolexp.induct|thm"><span class="entity_def" id="BoolExp.boolexp.case_transfer|thm"><span class="entity_def" id="BoolExp.boolexp.splits(2)|thm"><span class="entity_def" id="BoolExp.boolexp.splits(1)|thm"><span class="entity_def" id="BoolExp.boolexp.split_asm|thm"><span class="entity_def" id="BoolExp.boolexp.split|thm"><span class="entity_def" id="BoolExp.boolexp.nchotomy|thm"><span class="entity_def" id="BoolExp.boolexp.inject|thm"><span class="entity_def" id="BoolExp.boolexp.exhaust|thm"><span class="entity_def" id="BoolExp.boolexp.distinct(6)|thm"><span class="entity_def" id="BoolExp.boolexp.distinct(5)|thm"><span class="entity_def" id="BoolExp.boolexp.distinct(4)|thm"><span class="entity_def" id="BoolExp.boolexp.distinct(3)|thm"><span class="entity_def" id="BoolExp.boolexp.distinct(2)|thm"><span class="entity_def" id="BoolExp.boolexp.distinct(1)|thm"><span class="entity_def" id="BoolExp.boolexp.case_distrib|thm"><span class="entity_def" id="BoolExp.boolexp.case_cong_weak|thm"><span class="entity_def" id="BoolExp.boolexp.case_cong|thm"><span class="entity_def" id="BoolExp.boolexp.case(3)|thm"><span class="entity_def" id="BoolExp.boolexp.case(2)|thm"><span class="entity_def" id="BoolExp.boolexp.case(1)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(15)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(14)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(13)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(12)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(11)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(10)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(9)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(8)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(7)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(6)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(5)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(4)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(3)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(2)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.simps(1)|thm"><span class="entity_def" id="BoolExp.boolexp.eq.refl|thm"><span class="entity_def" id="BoolExp.arity_equal_boolexp|thm"><span class="entity_def" id="BoolExp.equal_boolexp_def|thm"><span class="entity_def" id="BoolExp.equal_boolexp_inst.equal_boolexp|thm"><span class="entity_def" id="BoolExp.arity_partial_term_of_boolexp|thm"><span class="entity_def" id="BoolExp.partial_term_of_boolexp_triv|thm"><span class="entity_def" id="BoolExp.partial_term_of_boolexp_inst.partial_term_of_boolexp|thm"><span class="entity_def" id="BoolExp.arity_term_of_boolexp|thm"><span class="entity_def" id="BoolExp.term_of_boolexp_triv|thm"><span class="entity_def" id="BoolExp.term_of_boolexp_inst.term_of_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.case_boolexp_def|thm"><span class="entity_def" id="BoolExp.boolexp.ctor_rec_boolexp_def|thm"><span class="entity_def" id="BoolExp.boolexp.dtor_boolexp_def|thm"><span class="entity_def" id="BoolExp.boolexp.ctor_fold_boolexp_def|thm"><span class="entity_def" id="BoolExp.boolexp.ctor_boolexp_def|thm"><span class="entity_def" id="BoolExp.arity_typerep_boolexp|thm"><span class="entity_def" id="BoolExp.typerep_boolexp_def|thm"><span class="entity_def" id="BoolExp.typerep_boolexp_inst.typerep_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.Abs_boolexp_induct|thm"><span class="entity_def" id="BoolExp.boolexp.Rep_boolexp_induct|thm"><span class="entity_def" id="BoolExp.boolexp.Abs_boolexp_cases|thm"><span class="entity_def" id="BoolExp.boolexp.Rep_boolexp_cases|thm"><span class="entity_def" id="BoolExp.boolexp.Abs_boolexp_inject|thm"><span class="entity_def" id="BoolExp.boolexp.Rep_boolexp_inject|thm"><span class="entity_def" id="BoolExp.boolexp.Abs_boolexp_inverse|thm"><span class="entity_def" id="BoolExp.boolexp.Rep_boolexp_inverse|thm"><span class="entity_def" id="BoolExp.boolexp.Rep_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.type_definition_boolexp|thm"><span class="entity_def" id="BoolExp.arity_type_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.str_init_boolexp_def|thm"><span class="entity_def" id="BoolExp.boolexp.arity_typerep_boolexp_IITN_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.typerep_boolexp_IITN_boolexp_def|thm"><span class="entity_def" id="BoolExp.boolexp.typerep_boolexp_IITN_boolexp_inst.typerep_boolexp_IITN_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Abs_boolexp_IITN_boolexp_induct|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Rep_boolexp_IITN_boolexp_induct|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Abs_boolexp_IITN_boolexp_cases|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Rep_boolexp_IITN_boolexp_cases|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Abs_boolexp_IITN_boolexp_inject|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Rep_boolexp_IITN_boolexp_inject|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Abs_boolexp_IITN_boolexp_inverse|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Rep_boolexp_IITN_boolexp_inverse|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Rep_boolexp_IITN_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.type_definition_boolexp_IITN_boolexp|thm"><span class="entity_def" id="BoolExp.arity_type_boolexp_IITN_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.min_alg_boolexp_def|thm"><span class="entity_def" id="BoolExp.boolexp.mor_boolexp_def|thm"><span class="entity_def" id="BoolExp.boolexp.alg_boolexp_def|thm"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.set_pre_boolexp_def|thm"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.rel_pre_boolexp_def|thm"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.map_pre_boolexp_def|thm"><span class="entity_def" id="BoolExp.boolexp.arity_typerep_boolexp_pre_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.typerep_boolexp_pre_boolexp_def|thm"><span class="entity_def" id="BoolExp.boolexp.typerep_boolexp_pre_boolexp_inst.typerep_boolexp_pre_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Abs_boolexp_pre_boolexp_induct|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Rep_boolexp_pre_boolexp_induct|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Abs_boolexp_pre_boolexp_cases|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Rep_boolexp_pre_boolexp_cases|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Abs_boolexp_pre_boolexp_inject|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Rep_boolexp_pre_boolexp_inject|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Abs_boolexp_pre_boolexp_inverse|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Rep_boolexp_pre_boolexp_inverse|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Rep_boolexp_pre_boolexp|thm"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.type_definition_boolexp_pre_boolexp|thm"><span class="entity_def" id="BoolExp.arity_type_boolexp_pre_boolexp|thm"><span class="entity_def" id="BoolExp.full_exhaustive_boolexp_def|axiom"><span class="entity_def" id="BoolExp.full_exhaustive_boolexp_inst.full_exhaustive_boolexp_def|axiom"><span class="entity_def" id="BoolExp.narrowing_boolexp_def|axiom"><span class="entity_def" id="BoolExp.narrowing_boolexp_inst.narrowing_boolexp_def|axiom"><span class="entity_def" id="BoolExp.random_boolexp_def_raw|axiom"><span class="entity_def" id="BoolExp.random_boolexp_inst.random_boolexp_def|axiom"><span class="entity_def" id="BoolExp.random_aux_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.size_boolexp_overloaded_def|axiom"><span class="entity_def" id="BoolExp.size_boolexp_inst.size_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.size_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.rec_boolexp_def|axiom"><span class="entity_def" id="BoolExp.equal_boolexp_def_raw|axiom"><span class="entity_def" id="BoolExp.equal_boolexp_inst.equal_boolexp_def|axiom"><span class="entity_def" id="BoolExp.partial_term_of_boolexp_triv_raw|axiom"><span class="entity_def" id="BoolExp.partial_term_of_boolexp_inst.partial_term_of_boolexp_def|axiom"><span class="entity_def" id="BoolExp.term_of_boolexp_triv_raw|axiom"><span class="entity_def" id="BoolExp.term_of_boolexp_inst.term_of_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.case_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.BIf_def|axiom"><span class="entity_def" id="BoolExp.boolexp.BFalse_def|axiom"><span class="entity_def" id="BoolExp.boolexp.BTrue_def|axiom"><span class="entity_def" id="BoolExp.boolexp.ctor_rec_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.dtor_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.ctor_fold_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.ctor_boolexp_def|axiom"><span class="entity_def" id="BoolExp.typerep_boolexp_def_raw|axiom"><span class="entity_def" id="BoolExp.typerep_boolexp_inst.typerep_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.type_definition_boolexp|axiom"><span class="entity_def" id="BoolExp.arity_type_boolexp|axiom"><span class="entity_def" id="BoolExp.boolexp.str_init_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.typerep_boolexp_IITN_boolexp_def_raw|axiom"><span class="entity_def" id="BoolExp.boolexp.typerep_boolexp_IITN_boolexp_inst.typerep_boolexp_IITN_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.type_definition_boolexp_IITN_boolexp|axiom"><span class="entity_def" id="BoolExp.arity_type_boolexp_IITN_boolexp|axiom"><span class="entity_def" id="BoolExp.boolexp.min_alg_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.mor_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.alg_boolexp_def|axiom"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.wit_pre_boolexp_def|axiom"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.pred_pre_boolexp_def|axiom"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.rel_pre_boolexp_def|axiom"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.set_pre_boolexp_def|axiom"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.map_pre_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.typerep_boolexp_pre_boolexp_def_raw|axiom"><span class="entity_def" id="BoolExp.boolexp.typerep_boolexp_pre_boolexp_inst.typerep_boolexp_pre_boolexp_def|axiom"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.type_definition_boolexp_pre_boolexp|axiom"><span class="entity_def" id="BoolExp.arity_type_boolexp_pre_boolexp|axiom"><span class="entity_def" id="BoolExp.raw_prod.boolexp.sum2.sum2.prod.Product_Type.wit_raw_prod_def|axiom"><span class="entity_def" id="BoolExp.full_exhaustive_boolexp_inst.full_exhaustive_boolexp|const"><span class="entity_def" id="BoolExp.narrowing_boolexp_inst.narrowing_boolexp|const"><span class="entity_def" id="BoolExp.random_boolexp_inst.random_boolexp|const"><span class="entity_def" id="BoolExp.random_aux_boolexp|const"><span class="entity_def" id="BoolExp.size_boolexp_inst.size_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.size_boolexp|const"><span class="entity_def" id="BoolExp.equal_boolexp_inst.equal_boolexp|const"><span class="entity_def" id="BoolExp.partial_term_of_boolexp_inst.partial_term_of_boolexp|const"><span class="entity_def" id="BoolExp.term_of_boolexp_inst.term_of_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.case_boolexp|const"><span class="entity_def" id="BoolExp.typerep_boolexp_inst.typerep_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.Abs_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.Rep_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.typerep_boolexp_IITN_boolexp_inst.typerep_boolexp_IITN_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Abs_boolexp_IITN_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp.Rep_boolexp_IITN_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.mor_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.alg_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.typerep_boolexp_pre_boolexp_inst.typerep_boolexp_pre_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Abs_boolexp_pre_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp.Rep_boolexp_pre_boolexp|const"><span class="entity_def" id="BoolExp.raw_prod.boolexp.sum2.sum2.prod.Product_Type.wit_raw_prod|const"><span class="entity_def" id="BoolExp.boolexp.boolexp_IITN_boolexp|type"><span>datatype</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="entity_def" id="BoolExp.boolexp.rec_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.ctor_rec_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.dtor_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.ctor_fold_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.ctor_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.str_init_boolexp|const"><span class="entity_def" id="BoolExp.boolexp.min_alg_boolexp|const"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.wit_pre_boolexp|const"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.pred_pre_boolexp|const"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.rel_pre_boolexp|const"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.set_pre_boolexp|const"><span class="entity_def" id="BoolExp.pre_boolexp.boolexp.map_pre_boolexp|const"><span class="entity_def" id="BoolExp.boolexp|type"><span class="entity_def" id="BoolExp.boolexp.boolexp_pre_boolexp|type"><span>boolexp</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="main"><span>=</span></span><span>
  </span><span class="entity_def" id="BoolExp.boolexp.BTrue|const"><span>BTrue</span></span><span> </span><span class="main"><span>|</span></span><span> 
  </span><span class="entity_def" id="BoolExp.boolexp.BFalse|const"><span>BFalse</span></span><span> </span><span class="main"><span>|</span></span><span> 
  </span><span class="entity_def" id="BoolExp.boolexp.BIf|const"><span>BIf</span></span><span> </span><span class="quoted"><span class="entity_ref"><span>boolexp</span></span></span><span> </span><span class="quoted"><span class="entity_ref"><span>boolexp</span></span></span><span> </span><span class="quoted"><span class="entity_ref"><span>boolexp</span></span></span><span></span>
</pre>

This is a simple AST definition allowing terms like `BIf BTrue BTrue BFalse` and `BIf (BIf BTrue BFalse BTrue) BTrue (BIf BTrue BFalse BTrue)`.

One way to prodce an _executable_ interpreter is with a big-step operational semantics. Here's one for this language:

<pre class="source">
<span class="keyword1"><span class="command"><span class="entity_def" id="BoolExp.is_value_def|fact"><span class="entity_def" id="BoolExp.is_value_def|thm"><span class="entity_def" id="BoolExp.is_value_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="BoolExp.is_value|const"><span>is_value</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="entity_ref"><span>boolexp</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><span>bool</span><span>"</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
</span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span>is_value</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="main"><span>(</span></span><span class="keyword1"><span>case</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t</span></span></span></span><span> </span><span class="keyword1"><span>of</span></span><span> BTrue </span><span class="main"><span>⇒</span></span><span> </span><span>True</span><span> </span><span class="main"><span>|</span></span><span> BFalse </span><span class="main"><span>⇒</span></span><span> </span><span>True</span><span> </span><span class="main"><span>|</span></span><span> </span><span class="main"><span class="bound"><span>_</span></span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><span>False</span><span class="main"><span>)</span></span><span>"</span></span></span>

<span class="keyword1"><span class="command"><span class="entity_def" id="BoolExp.bigstep.inducts|fact"><span class="entity_def" id="BoolExp.bigstep.simps|fact"><span class="entity_def" id="BoolExp.bigstep.induct|fact"><span class="entity_def" id="BoolExp.bigstep.cases|fact"><span class="entity_def" id="BoolExp.bigstep.intros|fact"><span class="entity_def" id="BoolExp.bigstep.inducts|thm"><span class="entity_def" id="BoolExp.bigstep.simps|thm"><span class="entity_def" id="BoolExp.bigstep.induct|thm"><span class="entity_def" id="BoolExp.bigstep.cases|thm"><span class="entity_def" id="BoolExp.bigstep.intros(3)|thm"><span class="entity_def" id="BoolExp.bigstep.intros(2)|thm"><span class="entity_def" id="BoolExp.bigstep.intros(1)|thm"><span class="entity_def" id="BoolExp.bigstep_def|axiom"><span>inductive</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="entity"><span class="entity_def" id="BoolExp.bigstep|const"><span>bigstep</span></span></span><span> </span><span class="main"><span>::</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="entity_ref"><span>boolexp</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><span class="entity_ref"><span>boolexp</span></span><span> </span><span class="main"><span>⇒</span></span><span> </span><span>bool</span><span>"</span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>where</span></span></span><span>
</span><span class="entity_def" id="BoolExp.bigstep.bval|fact"><span class="entity_def" id="BoolExp.bigstep.bval|thm"><span>bval</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="entity_re"><span>is_value</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t</span></span></span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="free"><span>bigstep</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t</span></span></span></span><span>"</span></span></span><span> </span><span class="main"><span>|</span></span><span>
</span><span class="entity_def" id="BoolExp.bigstep.bif_true|fact"><span class="entity_def" id="BoolExp.bigstep.bif_true|thm"><span>bif_true</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>⟦</span></span><span class="free"><span>bigstep</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t1</span></span></span></span><span> </span><span class="entity_re|const"><span>BTrue</span></span><span class="main"><span>;</span></span><span> </span><span class="free"><span>bigstep</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t2</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>v</span></span></span></span><span class="main"><span>⟧</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="free"><span>bigstep</span></span><span> </span><span class="main"><span>(</span></span><span class="entity_ref"><span>BIf</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t1</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t2</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t3</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>v</span></span></span></span><span>"</span></span></span><span> </span><span class="main"><span>|</span></span><span>
</span><span class="entity_def" id="BoolExp.bigstep.bif_false|fact"><span class="entity_def" id="BoolExp.bigstep.bif_false|thm"><span>bif_false</span></span></span><span class="main"><span>:</span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>⟦</span></span><span class="free"><span>bigstep</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t1</span></span></span></span><span> </span><span class="entity_ree|const"><span>BFalse</span></span><span class="main"><span>;</span></span><span> </span><span class="free"><span>bigstep</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t3</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>v</span></span></span></span><span class="main"><span>⟧</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="free"><span>bigstep</span></span><span> </span><span class="main"><span>(</span></span><span class="entity_ref"><span>BIf</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t1</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t2</span></span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t3</span></span></span></span><span class="main"><span>)</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>v</span></span></span></span><span>"</span></span></span>
</pre>

An inductive definition like this describes legal evaluations as predicates on the start and end terms. For example, the `bif_true` rule says that if we know that `t1` evaluates to `BTrue`, and `t2` evaluates to `v`, then `(BIf t1 t2 t3)` evaluates to `v`. If we think of this in concrete syntax, it just means that to evaluate `if true then t2 else t3`, we first recursively evaluate `t2` because the conditional is true. Then the whole expression evaluates to the result, which is `v`. The `bval` rule just makes sure that the operation terminates once a value of `BTrue` or `BFalse` is reached, where they just evaluate to themselves.

It's common to define semantics like this in proof assistants, ([though it's not the only way to do it](https://www.cs.kent.ac.uk/people/staff/sao/documents/esop16.pdf)), but a couple of incantations are necessary to make it actually executable:

<pre class="source">
<span class="keyword1"><span class="command"><span class="entity_def" id="BoolExp.bigstep.equation|fact"><span class="entity_def" id="BoolExp.bigstep&apos;E|fact"><span class="entity_def" id="BoolExp.bigstep&apos;I|fact"><span class="entity_def" id="BoolExp.bigstep&apos;_def|fact"><span class="entity_def" id="BoolExp.bigstep.equation|thm"><span class="entity_def" id="BoolExp.bigstep&apos;E|thm"><span class="entity_def" id="BoolExp.bigstep&apos;I|thm"><span class="entity_def" id="BoolExp.bigstep&apos;_def|thm"><span class="entity_def" id="BoolExp.bigstep&apos;_def|axiom"><span class="entity_def" id="BoolExp.bigstep&apos;|const"><span>code_pred</span></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="main"><span>(</span></span><span>modes</span><span class="main"><span>:</span></span><span> i </span><span class="main"><span>=&gt;</span></span><span> o </span><span class="main"><span>=&gt;</span></span><span> bool as bigstep'</span><span class="main"><span>)</span></span><span> </span><span class="quoted"><span class="entity_re"><span class="quoted"><span class="entity_re"><span>bigstep</span></span></span></span></span><span> </span><span class="keyword1"><span class="command"><span>.</span></span></span><span> 

</span><span class="keyword1"><span class="command"><span class="entity_def" id="BoolExp.bigstep_ex_def|fact"><span class="entity_def" id="BoolExp.bigstep_ex_def|thm"><span class="entity_def" id="BoolExp.bigstep_ex_def_raw|axiom"><span>definition</span></span></span></span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="free"><span class="entity_def" id="BoolExp.bigstep_ex|const"><span>bigstep_ex</span></span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t</span></span></span></span><span> </span><span class="main"><span>=</span></span><span> </span><span>Predicate.the</span><span> </span><span class="main"><span>(</span></span><span class="entity_ref"><span>bigstep'</span></span><span> </span><span class="free"><span class="bound"><span class="entity"><span>t</span></span></span></span><span class="main"><span>)</span></span><span>"</span></span></span>
</pre>

There's a whole section devoted to inductive predicates and code generation in [the Isabelle codegen documentation](https://isabelle.in.tum.de/doc/codegen.pdf), but long story short this just turns the set of evaluation transitions into a function that instead computes the result given a starting term. These are really just two different ways of expressing the same concept, but the function version is the one that we can actually use to evaluate terms as we're used to with executable interpreters.

Now we can evaluate the example terms from before to see that our semantics evaluates an input term vs. just describing legal transitions:

<pre class="source">
<span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>"</span><span>evalulates to: BTrue</span><span>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>value</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="entity_re"><span>bigstep_ex</span></span><span> </span><span class="main"><span>(</span></span><span class="entity_ref"><span>BIf</span></span><span> </span><span class="entity_re|const"><span>BTrue</span></span><span> </span><span class="entity_re|const"><span>BTrue</span></span><span> </span><span class="entity_ree|const"><span>BFalse</span></span><span class="main"><span>)</span></span><span>"</span></span></span><span>

</span><span class="keyword1"><span class="command"><span>text</span></span></span><span> </span><span class="quoted"><span class="plain_text"><span>"</span><span>evalutes to: BFalse</span><span>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>value</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="entity_re"><span>bigstep_ex</span></span><span> </span><span class="main"><span>(</span></span><span class="entity_ref"><span>BIf</span></span><span> </span><span class="main"><span>(</span></span><span class="entity_ref"><span>BIf</span></span><span> </span><span class="entity_re|const"><span>BTrue</span></span><span> </span><span class="entity_ree|const"><span>BFalse</span></span><span> </span><span class="entity_re|const"><span>BTrue</span></span><span class="main"><span>)</span></span><span> </span><span class="entity_re|const"><span>BTrue</span></span><span> </span><span class="main"><span>(</span></span><span class="entity_ref"><span>BIf</span></span><span> </span><span class="entity_re|const"><span>BTrue</span></span><span> </span><span class="entity_ree|const"><span>BFalse</span></span><span> </span><span class="entity_re|const"><span>BTrue</span></span><span class="main"><span>)</span></span><span class="main"><span>)</span></span><span>"</span></span></span>
</pre>

# Metatheoretical Determinism

Just to show that this semantics can be used in a real proof, here's a proof that the semantics is deterministic, i.e. any term always evaluates to the same value. This isn't always the case, particularly when concurrency gets introduced to the language, so knowing that our language has this property or not is useful:

<pre class="source">
<span class="keyword1"><span class="command"><span>theorem</span></span></span><span> </span><span class="quoted"><span class="quoted"><span>"</span><span class="main"><span>⟦</span></span><span class="entity_re"><span>bigstep</span></span><span> </span><span class="free"><span>t</span></span><span> </span><span class="free"><span>t'</span></span><span class="main"><span>;</span></span><span> </span><span class="entity_re"><span>bigstep</span></span><span> </span><span class="free"><span>t</span></span><span> </span><span class="free"><span>t''</span></span><span class="main"><span>⟧</span></span><span> </span><span class="main"><span>⟹</span></span><span> </span><span class="free"><span>t'</span></span><span> </span><span class="main"><span>=</span></span><span> </span><span class="free"><span>t''</span></span><span>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span>proof</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>induction</span></span><span> </span><span class="quoted"><span class="free"><span>t</span></span></span><span> </span><span class="quoted"><span class="free"><span>t'</span></span></span><span> </span><span class="quasi_keyword"><span>arbitrary</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span class="quoted"><span class="free"><span>t''</span></span></span><span> </span><span class="quasi_keyword"><span>rule</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span class="entity_ret|fact"><span>bigstep.induct</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword3"><span class="command"><span>case</span></span></span><span> </span><span class="main"><span>(</span></span><span>bval</span><span> </span><span class="skolem"><span>t</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>then</span></span></span><span> </span><span class="keyword3"><span class="command"><span>show</span></span></span><span> </span><span class="var"><span class="quoted"><span class="var"><span>?case</span></span></span></span><span> </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>auto</span></span><span> </span><span class="quasi_keyword"><span>simp</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span class="entity_ref"><span>is_value_def</span></span><span> </span><span class="quasi_keyword"><span>intro</span></span><span class="main"><span class="main"><span>:</span></span></span><span> </span><span class="entity_re|fact"><span>bigstep.cases</span></span><span class="main"><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>next</span></span></span><span>
  </span><span class="keyword3"><span class="command"><span>case</span></span></span><span> </span><span class="main"><span>(</span></span><span>bif_true</span><span> </span><span class="skolem"><span>t1</span></span><span> </span><span class="skolem"><span>t2</span></span><span> </span><span class="skolem"><span>v</span></span><span> </span><span class="skolem"><span>t3</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>then</span></span></span><span> </span><span class="keyword3"><span class="command"><span>show</span></span></span><span> </span><span class="var"><span class="quoted"><span class="var"><span>?case</span></span></span></span><span>
    </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>smt</span></span><span> </span><span class="main"><span class="main"><span>(</span></span></span><span>verit</span><span class="main"><span class="main"><span>,</span></span></span><span> best</span><span class="main"><span class="main"><span>)</span></span></span><span> </span><span class="entity_re|fact"><span>bigstep.cases</span></span><span> </span><span class="entity_renct|fact"><span>boolexp.distinct</span></span><span class="main"><span class="main"><span>(</span></span></span><span>1</span><span class="main"><span class="main"><span>)</span></span></span><span> </span><span class="entity_ret|fact"><span>boolexp.inject</span></span><span> </span><span class="entity_re|fact"><span>boolexp.simps</span></span><span class="main"><span class="main"><span>(</span></span></span><span>10</span><span class="main"><span class="main"><span>)</span></span></span><span> </span><span class="entity_ref"><span>is_value_def</span></span><span class="main"><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>next</span></span></span><span>
  </span><span class="keyword3"><span class="command"><span>case</span></span></span><span> </span><span class="main"><span>(</span></span><span>bif_false</span><span> </span><span class="skolem"><span>t1</span></span><span> </span><span class="skolem"><span>t3</span></span><span> </span><span class="skolem"><span>v</span></span><span> </span><span class="skolem"><span>t2</span></span><span class="main"><span>)</span></span><span>
  </span><span class="keyword1"><span class="command"><span>then</span></span></span><span> </span><span class="keyword3"><span class="command"><span>show</span></span></span><span> </span><span class="var"><span class="quoted"><span class="var"><span>?case</span></span></span></span><span>
    </span><span class="keyword1"><span class="command"><span>by</span></span></span><span> </span><span class="main"><span>(</span></span><span class="operator"><span>smt</span></span><span> </span><span class="main"><span class="main"><span>(</span></span></span><span>verit</span><span class="main"><span class="main"><span>)</span></span></span><span> </span><span class="entity_re|fact"><span>bigstep.cases</span></span><span> </span><span class="entity_renct|fact"><span>boolexp.distinct</span></span><span class="main"><span class="main"><span>(</span></span></span><span>1</span><span class="main"><span class="main"><span>)</span></span></span><span> </span><span class="entity_ret|fact"><span>boolexp.inject</span></span><span> </span><span class="entity_re|fact"><span>boolexp.simps</span></span><span class="main"><span class="main"><span>(</span></span></span><span>10</span><span class="main"><span class="main"><span>)</span></span></span><span> </span><span class="entity_ref"><span>is_value_def</span></span><span class="main"><span>)</span></span><span>
</span><span class="keyword1"><span class="command"><span>qed</span></span></span>
</pre>

The point of this post isn't really the proof itself, and in full disclosure the last 2 cases of the proof were found with Isabelle's famous [sledgehammer](https://lawrencecpaulson.github.io/2022/04/13/Sledgehammer.html) :). This "language" is silly and small, so we won't go any further with proving any metatheoretical properties about it, but it is important to show that the same definition that can be used in proof can be executed as a real program. Which brings us to...

# Crossing the Verification Gap: From Isabelle to OCaml

If we hand-build a compiler or interpreter for our language, it might diverge from our semantics in subtle ways. Isabelle offers code extraction functionality though, and we can just extract the logic we just verified into an equivalent OCaml program:

<pre class="source">
<span class="keyword1"><span class="command"><span>export_code</span></span></span><span> </span><span class="quoted"><span class="quoted"><span class="entity_re"><span>bigstep_ex</span></span></span></span><span> </span><span class="quoted"><span class="quoted"><span class="entity_re|const"><span>BTrue</span></span></span></span><span> </span><span class="keyword2"><span class="keyword"><span>in</span></span></span><span> OCaml </span><span class="keyword2"><span class="keyword"><span>file_prefix</span></span></span><span> </span><span class="quoted"><span>"</span><span>core</span><span>"</span></span>
</pre>

Exporting the `bigstep_ex` function is obviously necessary, but exporting the `BTrue` constructor of the `boolexp` datatype might look surprising. It ends up being necessary because Isabelle generates all code inside of an OCaml module, and without this the datatype constructors would be private to the module. Since we're going to parse and execute real code, we need to create values of type `boolexp` from outside of this module, and exporting a single constructor is enough to have Isabelle export all of the constructors.

That brings us to the final step, where we'll parse source code and evaluate it using our extracted semantics.

# Parsing and Evaluation

Here's a quick lexer (using `ocamllex`):

```
{
  open Lexing
  open Parser

  exception SyntaxError of string
}

let whitespace = [' ' '\t' '\r' '\n']

rule read = parse
  | whitespace+       { read lexbuf }
  | "true"            { TRUE }
  | "false"           { FALSE }
  | "if"              { IF }
  | "then"            { THEN }
  | "else"            { ELSE }
  | '('               { LPAREN }
  | ')'               { RPAREN }
  | _                 { raise (SyntaxError ("Unexpected char: " ^ Lexing.lexeme lexbuf)) }
  | eof               { EOF }
```

And the corresponding parser (using `menhir`):

```
%{
open Core.BoolExp
%}

// Values
%token TRUE
%token FALSE

%token IF
%token THEN
%token ELSE

%token LPAREN
%token RPAREN
%token EOF

%start prog
%type <boolexp option> prog 

%%

prog: 
  | e = expression EOF { Some e }
  | EOF                { None };

expression:
  | TRUE                          { BTrue }
  | FALSE                         { BFalse}
  | IF e1 = expression THEN e2 = expression ELSE e3 = expression 
                                  { BIf(e1, e2, e3) }
  | LPAREN e = expression RPAREN  { e }
```

Note that in between curly braces we're creating OCaml values that correspond to our `boolexp` AST defined in Isabelle. This is the step where we go from a piece of source code to a piece of structured syntax that our executable semantics can actually execute.

Top this all off with a little bit of glue code to lex and parse a source code string, and we can execute the more complicated of our previous syntax examples:

~~~
open Bexp_ocaml
open Bexp_ocaml.Lexer
open Lexing

let evaluate expr =
  let lexbuf = Lexing.from_string expr in
  match Parser.prog Lexer.read lexbuf with
  | Some value ->
    let parsed = Util.string_of_boolexp value in
    Printf.printf "Parsed term: %s\n" parsed;

    let result = Core.BoolExp.bigstep_ex value |> Util.string_of_boolexp in
    Printf.printf "Result: %s\n" result;
  | None -> ()

let () = evaluate "if (if true then false else true) then true else (if true then false else true)"; ()
~~~
{: .language-ocaml}

This evalutes to `BFalse`, just as it did in Isabelle, and we now have a verified and executable interpreter for terms in our language.

Behind the scenes there's a little more OCaml setup with dune to get all this to build, and the full example can be [found here](https://github.com/amw-zero/interp_verified). The full exported OCaml code is also there, which we've omitted here for brevity.

# Now What?

Now that we have this interpreter what can what can we do with it? We can of course just use it directly if we want our language to stay interpreted and that's it. But it can also be used as a source of truth for other language components.

For example, Conrad Watt [formalized the semantics of WebAssembly](https://www.cl.cam.ac.uk/~caw77/papers/mechanising-and-verifying-the-webassembly-specification.pdf) and used it to check wasm implementations against an extracted reference interpreter using fuzz testing. This is a hybrid approach, somewhere between program extraction and model-based test case generation, and it allows for hand-writing a language implementation while still being "connected" to the verified semantics. 

Having an executable version of our semantics enables other similar workflows - any place where we want to check for what the definition of correctness is, we now have an oracle.

# Wrapping Up

Extraction is one way to handle the verification gap, and Isabelle's extraction engine is both very powerful and customizable - [documentation here](https://isabelle.in.tum.de/doc/codegen.pdf). Once extracted, the language semantics is no longer just a mathematical model, but can be used to execute real programs. It has to be said that code generation isn't guaranteed to be correct in terms of preserving the semantics of the Isabelle version. The reason it's not guaranteed is because OCaml doesn't have a formal semantics, so there can be no proof about its programs. In practice, however, this isn't a huge problem, because HOL maps very directly to the informal semantics of a functional language like OCaml.

Proof assistants can seem like intimidating tools, but hopefully this showed that a verified interpreter can be extracted with a surprisingly small amount of effort. Of course larger languages will have more complicated semantics and associated proofs, but the end-to-end idea can be carried out pretty easily.

<hr>
