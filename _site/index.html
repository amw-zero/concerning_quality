<!DOCTYPE html>
<html lang="en">
<title>Home | Concerning Quality</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="author" content="Alex Weisberger">
<meta name="generator" content="Jekyll v4.2.1">
<link rel="canonical" href="http://localhost:4000/">

<link rel="stylesheet" href="/assets/css/frame.css">

<link rel="alternate" href="/feed.xml" type="application/atom+xml" title="Concerning Quality">

<link rel="stylesheet" href="/assets/katex/katex.min.css">
<script defer src="/assets/katex/katex.min.js"></script>
<script defer src="/assets/katex/contrib/auto-render.min.js" onload="renderMathInElement(document.body)"></script>







<header>
  <a href="/" class="title">Concerning Quality</a>
  <nav><a href="/" class="selected">Home</a></nav>

</header>


  
  <article>
    <header>
  <h1><a href="/quality-and-paradigm/">Quality and Paradigm: The Assembly Language of Reasoning and the Domain-Specific Language of the Machine</a></h1><time datetime="2021-12-30T00:00:00-05:00">December 30, 2021</time>
</header>

    <p>Does programming paradigm affect the ultimate quality of software? I generally avoid stoking the eternal flame war of functional vs. imperative programming, but it has to be discussed since there are so many repeated statements of fact about which one leads to higher-quality programs<sup id="fnref:fn1" role="doc-noteref"><a href="#fn:fn1" class="footnote" rel="footnote">1</a></sup>. The arguments primarily exist along two dimensions: correctness and performance. Summing them up, functional programs are more correct but slow, and imperative programs are buggy but fast. Of course, there are counterexamples to each of these statements, but this is a fair generalization overall.</p>

<p>Thinking of it as a competition isn’t helpful though, because each paradigm has a different purpose: FP is optimized for mathematical reasoning, whereas imperative programming is fundamentally about manipulating computer hardware. It’s this difference between reasoning and practical execution that suggests that the highest quality software actually requires utlizing both paradigms: no matter what level we write code at, we must be able to reason about how that code runs at the level of real-world machines. This is what allows us to achieve the holy grail of quality: fast and correct software.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:fn1" role="doc-endnote">
      <p>We’ll leave out other paradigms from this discussion, such as logic programming, acknowledging that FP and imperative aren’t the only possible programming paradigms. <a href="#fnref:fn1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    <div class="more"><a href="/quality-and-paradigm/">read more</a></div>
  </article>

  <article>
    <header>
  <h1><a href="/refinement/">Refinement: Formalizing the Simplicity Underneath Complex Programs</a></h1><time datetime="2021-11-26T00:00:00-05:00">November 26, 2021</time>
</header>

    <p>“Real world” software is large, messy, and full of detail. A customer might just want to store and retrieve their data, but those simple requirements can get lost in the sea of programming language semantics, libraries, frameworks, databases, Internet protocols, serialization formats, performance optimizations, security hardening, auditability, monitorability, asynchronicity, etc., etc., ad infinitum. We should always try to simplify our stack, but practical computation is optimization to an extent - how would you like to use a logically correct application where each interaction takes 10 seconds to give feedback?</p>

<p>To really understand this difference between functional and non-functional requirements, let’s look at the concept of <em>refinement</em>. Refinement is the fundamental concept behind behavior-preserving program transformation, and it allows us to separate abstraction from implementation in a formal and verifiable process.</p>

    <div class="more"><a href="/refinement/">read more</a></div>
  </article>

  <article>
    <header>
  <h1><a href="/misspecification/">Misspecification: The Blind Spot of Formal Verification</a></h1><time datetime="2021-10-06T00:00:00-04:00">October 06, 2021</time>
</header>

    <p>As people, we like to be right, and we also want to avoid the effort of <em>proving</em> that we’re right. So we often resort to logical fallacies to take shortcuts and strong-arm people into believing us. One such logical fallacy is an <a href="https://en.wikipedia.org/wiki/Argument_from_authority">“appeal to authority”</a> - you simply reference someone or thing that is considered to be an expert, and voilá - now you are right!</p>

<p>The reason it’s a logical fallacy is that even smart people make mistakes. Or, even more importantly, smart people can have ill-intent - what better way to use social capital than to convince your followers to buy your new book and pay for your next vacation? That’s why papers should be peer-reviewed. That’s why we reproduce empirical experiments. And that’s why we should always have healthy skepticism and evaluate an argument for ourselves.</p>

<p>Formal verification is often presented as an appeal to authority. This progam was <em>formally verified</em>, so please stop asking me if there are any bugs! Well, there are simply no silver bullets out there, and formal verification is certainly not one of them because of a very serious blind spot: the possibility of misspecification.</p>

    <div class="more"><a href="/misspecification/">read more</a></div>
  </article>

  <article>
    <header>
  <h1><a href="/state-explosion/">State Space Explosion: the Reason We Can Never Test Software to Perfection</a></h1><time datetime="2021-01-02T00:00:00-05:00">January 02, 2021</time>
</header>

    <p>Have you ever seen a test suite actually prevent 100% of bugs? With all of the time that we spend testing software, how do bugs still get through? Testing seems ostensibly simple – there are only so many branches in the code, only so many buttons in the UI, only so many edge cases to consider. So what is difficult about testing software?</p>

<p><strong>This post is dedicated to <a href="https://en.wikipedia.org/wiki/Edmund_M._Clarke">Edmund Clarke</a>, who spent a large portion of his life pioneering solutions to the <a href="https://www.youtube.com/watch?v=I1lf2MBy3J4&amp;t=1096s">state explosion problem</a>.</strong></p>

    <div class="more"><a href="/state-explosion/">read more</a></div>
  </article>

  <article>
    <header>
  <h1><a href="/why-quality/">Why Quality?</a></h1><time datetime="2020-12-19T00:00:00-05:00">December 19, 2020</time>
</header>

    <p>First thing’s first: why should we care about the quality of software?</p>

<p>Does it matter?<sup id="fnref:fn1" role="doc-noteref"><a href="#fn:fn1" class="footnote" rel="footnote">1</a></sup> The answer, like all answers, is that it completely depends on the context. Software is vastly diverse, and not all applications require the same level of quality and reliability. The most obvious litmus test is “will people die if the application fails to perform its job?” That isn’t the only dimension to consider, though. For example, people are very sensitive to mistakes made with their money. Our time is precious, our money is earned, and we expect our banking software to work correctly.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:fn1" role="doc-endnote">
      <p>I definitely think it matters, but it’s a little more complicated than that. <a href="#fnref:fn1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    <div class="more"><a href="/why-quality/">read more</a></div>
  </article>








<footer>
  <nav><a href="https://twitter.com/amw_zero" ><svg aria-label="" class="icon"><use xlink:href="/assets/fontawesome/icons.svg#twitter"></use></svg></a><a href="mailto:alex.m.weisberger@gmail.com" ><svg aria-label="Mail" class="icon"><use xlink:href="/assets/fontawesome/icons.svg#envelope"></use></svg></a><a href="https://github.com/amw-zero" ><svg aria-label="Github" class="icon"><use xlink:href="/assets/fontawesome/icons.svg#github"></use></svg></a><a href="/feed.xml" ><svg aria-label="Subscribe" class="icon"><use xlink:href="/assets/fontawesome/icons.svg#rss"></use></svg></a></nav>

</footer>


</html>
